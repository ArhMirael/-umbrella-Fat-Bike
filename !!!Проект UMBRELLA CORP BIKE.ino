
//ПРОЕКТ БАЙК UMBRELLA CORP

#include <Wire.h> 
#include <LiquidCrystal_I2C.h>
LiquidCrystal_I2C lcd(0x27,16,2);  // Инициализация библиотек для дисплея
//Использует аналоговыевыходы A4, A5

//Тут делаем общёт скорости
byte n = 3;      // число Магнитов мотор колеса
float r = 3.5;   // радиус тела В САНТИМЕТРАХ

//Для расчётов оборотов
float r_speed, rev_time;
volatile unsigned long lastflash, flash, lastshow;
unsigned int RPM;
String spaces = "       ";

// Переменные для модулей РЕЛЕ
const int R1 = 3; //Реле включения байка с помощью модуля FingerPrint
const int R2 = 4; //Реле стоп сигналов байка. Включает габариты при нажатии ручек тормоза. сигнал берем с герконов
const int R3 = 5; //Реле подцветки. Включает светодиодную подцветку байка расположенную в крыльях.

//Переменные для входящих сигналов с байка
int FPBUTTON = 7; //Finger Print кнопка. при считывании включает реле, при повторном считывании выключает. 7pin
int WBUTTON1 = 6; // WIRLES BUTTON отвечает за подцветку.
int GBUTTON = A0; //Переменная для считывания сигнала с герконов. при замыкании появляется сигнал, при его появлении включается реле.
// он привязан к аналог пин 0
int SPEED = 8; // для считывания аналоговых значений с мотор колеса, для измерения скорости. значения с неё обрабатываем и будем выводить на дисплей.

// Также!!! Дублирующая система Wirless Button для fingerPrint если даёт сбой, то включить можно будет с кнопки на пульте ДУ.

// Переменные для хранения данных
int VAL_G = 0; // переменная для хранения значений с герконов

// Переменные и модули используемые для проекта определены. проводим инициализацию модулей

void setup()
{
    Serial.begin(9600); //Включаем для отладки значений сигналов с герконов и настройки скорости в КМ
    pinMode(R1, OUTPUT); //Включаем реле как выходы
    pinMode(R2, OUTPUT);
    pinMode(R3, OUTPUT);
    // Расчёт скорости
    attachInterrupt(0, sens, RISING);    // подключить прерывание на 2 пин при повышении сигнала
    
    // Включаем входящие кнопки( возможно придётся закоментировать FPBUTTON и WBUTTON так как нужно будет инвертировать их значения )
    pinMode(FPBUTTON, INPUT);//Инициализируем как входящие сигналы для дальнейшей обработки
    pinMode(WBUTTON1, INPUT);
    pinMode(GBUTTON, INPUT);
    pinMode(SPEED, INPUT);
    //Выводим на дисплей сообщение
    lcd.init();//Включаем дисплей           
    lcd.backlight();// Включаем подсветку дисплея
    lcd.print("Umbrella Corp"); //Пенрвая втрочка 15символ
    lcd.setCursor(0, 1);// выставляем на вторую строчку
    lcd.print("SPEED KM\h:");// Выводим вообщение на вторую строчку 11 символов на 13 символе будем выводить значение скорости
}

//расчёт скорости
void sens()
{
  flash = micros() - lastflash;   // вычислить время между двумя оборотами
  lastflash = micros();           // запомнить время последнего оборота
}

// Переходим к операционным функциям

void loop()
{
    // (старое не использовать)производим расчёт скорости. считывая аналоговый сигнал с контроллера
   /* VAL_S = analogRead(SPEED); // записываем значение с контроллера скорее всего зелёный провод
    VAL_S = map (VAL_S, 0, 1023, 0, 120); // значения взяты приблизительно. требует отладки
    VAL_S = constrain (VAL_S, 0, 120); //выравниваем значение чтобы не перкосило
    */
   // Новый расчёт скорости
   if (micros() - lastflash > 1000000) { // если сигнала нет больше секунды
    RPM = 0;                            // считаем, что всё стоит и не крутится
    r_speed = 0;
  } else {
    rev_time = (float) flash / 1000000 * n;             // время одного оборота в секундах, с учётом числа лопастей
    RPM = (float) 60 / rev_time;                        // обороты в минуту
    r_speed = (float) 2 * 3.1415 * r / 100 / rev_time * 3.6;  // скорость точки на радиусе, км/ч
  }
  
  // выводим значения на дисплей
  if (millis() - lastshow > 300) 
  {  // кадждые 300 миллисекунд
    lcd.setCursor(15, 0);  // курсор 13 слева 2 строчка
    lcd.print(RPM);       // выводим RPM
    lcd.print(spaces);    // очищаем цифры с прошлого вывода
    lcd.setCursor(13, 1); // курсор 10 слева 2 строчка
    lcd.print(r_speed);   // выводим скорость
    lcd.print(spaces);    // очищаем цифры с прошлого вывода
    lastshow = millis();  // сброс таймера
  }
   
    // Выводим значения в дисплей и в монитор порта
    // старые параметры для расчёта скорости Не использовать
    //lcd.setCursor(13, 1); //выставляем на вторую строку 13 символ вторая строка
    //lcd.print(VAL_S, DEC); // выводим на дисплей значение скорости
    Serial.print("SPEED: ");
    Serial.print(r_speed); // нужно для отладки, во вторуй не забыть println чтобы перейти на след строку
    // Далее переходим к герконам. включение стоп сигналов
    VAL_G = analogRead(GBUTTON); //считываем значение с геркона
    VAL_G = map (VAL_G, 1024, 0, 1, 0); //выравниваем на аналоговый пин
    VAL_G = constrain (VAL_G, 1, 0); // приводим значение к константовому
    if(VAL_G < 1) //Если значение меньше 1 то не включать реле стоп сигнала
    {
        digitalWrite(R2,LOW); // Реле в положении выключено
        Serial.println("GO");// в монитор порта отправляем GO
        delay(500); //задержка для монитора порта
        // старые параметры. не использовать
        //lcd.setCursor(15, 0);//выставляем на дисплее курсор на 15 символ первой строки
        //lcd.print("GO");// выводим сообщение GO на дисплей
    }
    else //если значение больше 0 то выполняем это действие
    {
        digitalWrite(R2, HIGH); // Включаем реле стоп сигналов
        //lcd.setCursor(15, 0);//выставляем на дисплее курсор на 15 символ первой строки
        //lcd.print("ST");// выводим значение стоп на дисплей
        Serial.println("STOP");//и в монитор порта
        delay(500);
    }
    // Переходим к кнопкам для включения и выключения Байка Finger Print модуль
    if(digitalRead(FPBUTTON) == HIGH) // если кнопка нажата то выполняем нижеследующее
    {
        
        digitalWrite(R1, !digitalRead(R1)); //Инвертируем значение для сигнала реле
        delay(2000); //задержка 2 секунды
        Serial.println("PRESS FINGERPRINT");
        /*
        
        if(!digitalRead(Led)) // если пришло значение инвертированное, тоесть выключен, то отправляем сообщение OFF
          {
            Serial.println("OFF");
          
          }
          else // если пришло не инвертированное значение, то отправляем сообщение ON в монитор порта
          {
            Serial.println("ON");
          }
          */ //закрыто
        }
    //Переходим к кнопке включения реле светодиодов подцветки
    if(digitalRead(WBUTTON1) == HIGH)
    {
        digitalWrite(R3, !digitalRead(R3)); //Инвертируем значение для сигнала реле
        delay(2000); //задержка 2 секунды
        Serial.println("PRESS LED LIGHT");
    }
}
